# List of all the Algorithms implemented in this repository

## Searching Alogrithms

    1    Linear search: This algorithm checks every item in a list or array until it finds the target value.

    2   Binary search: This algorithm only works with sorted lists or arrays. It repeatedly divides the search interval in half until the target value is found.

    3      Depth-first search (DFS): This algorithm traverses a graph by going as deep as possible along each branch before backtracking. It is often used in combination with other algorithms to solve problems such as finding the shortest path.

    4    Breadth-first search (BFS): This algorithm traverses a graph by visiting all nodes at the current depth before moving on to nodes at the next depth. It is often used to find the shortest path in an unweighted graph.

    5    Interpolation search: This algorithm works well on uniformly distributed data. It uses a formula to predict where the target value might be in the list or array and then performs a binary search.
    
    6    Jump search: This algorithm works well on sorted data. It divides the list or array into blocks and jumps to the beginning of the block that contains the target value.

    7    A* search: This algorithm is a variant of BFS that uses a heuristic function to estimate the distance from each node to the goal. It is often used to find the shortest path in a weighted graph.

    8    Exponential search: This algorithm works well on sorted data. It first finds an interval in which the target value might be and then performs a binary search within that interval.

    9    Fibonacci search: This algorithm works well on sorted data. It uses a Fibonacci sequence to divide the list or array into blocks and then performs a binary search within the block that contains the target value.
    
    10    Ternary search: This algorithm works well on uniformly distributed data. It divides the list or array into three parts and then performs a binary search within the part that contains the target value.

    11    Sublist search: This algorithm works well on sorted data. It uses a binary search to find the first element of the target list or array in the larger list or array and then checks the remaining elements.

## Sorting Algorithms

    1   Bubble sort: This algorithm repeatedly swaps adjacent elements that are out of order.

    2   Selection sort: This algorithm repeatedly finds the smallest element in the list or array and places it at the beginning.

    3   Insertion sort: This algorithm repeatedly inserts the next element in the list or array into the correct position in the sorted part of the list or array.

    4   Merge sort: This algorithm repeatedly divides the list or array into two halves, sorts each half, and then merges the two halves into a sorted list or array.

    5   Quick sort: This algorithm repeatedly selects a pivot element and partitions the list or array around the pivot.

    6   Heap sort: This algorithm repeatedly swaps the first element of the list or array with the last element and then restores the heap property.

    7   Counting sort: This algorithm counts the number of occurrences of each element in the list or array and then uses those counts to place each element in the correct position in the sorted list or array.

    8   Radix sort: This algorithm sorts the list or array by repeatedly sorting the elements by each digit.

    9   Bucket sort: This algorithm sorts the list or array by placing each element into a bucket and then sorting each bucket.

    10   Shell sort: This algorithm sorts the list or array by repeatedly dividing the list or array into smaller sublists and then sorting those sublists.

    11   Comb sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    12   Pigeonhole sort: This algorithm sorts the list or array by placing each element into a pigeonhole and then sorting each pigeonhole.

    13   Cycle sort: This algorithm repeatedly swaps the next element in the list or array with the element that should be there.

    14   Bitonic sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    15   Pancake sort: This algorithm sorts the list or array by repeatedly flipping the sublist from the beginning of the list or array to the current element.

    16   Stooge sort: This algorithm sorts the list or array by repeatedly sorting the first two-thirds of the list or array and then the last two-thirds of the list or array and then the first two-thirds of the list or array again.

    17   Strand sort: This algorithm sorts the list or array by repeatedly sorting the first two elements of the list or array and then inserting the next element in the correct position in the sorted sublist.

    18   Bogo sort: This algorithm repeatedly shuffles the list or array until it is sorted.

    19   Gnome sort: This algorithm sorts the list or array by repeatedly moving the first unsorted element to its correct position in the sorted part of the list or array.

    20   Cocktail sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    21   Odd-even sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    22   Slow sort: This algorithm sorts the list or array by repeatedly finding the minimum element and moving it to the beginning of the list or array.

    23   Tree sort: This algorithm sorts the list or array by repeatedly inserting each element into a binary search tree and then traversing the tree in order.

    24   Cube sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    25   Flash sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    26   Smooth sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    27   Strand sort: This algorithm sorts the list or array by repeatedly sorting the first two elements of the list or array and then inserting the next element in the correct position in the sorted sublist.

    28   Tim sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    29   Intro sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    30   Library sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

    31   Tournament sort: This algorithm sorts the list or array by repeatedly comparing adjacent elements and swapping them if they are in the wrong order.

## Graph Algorithms

    1 Breadth-first search: This algorithm starts at the root node and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.

    2 Depth-first search: This algorithm starts at the root node and explores as far as possible along each branch before backtracking.

    3 Dijkstra's algorithm: This algorithm finds the shortest path from the source node to all other nodes in the graph.

    4 Bellman-Ford algorithm: This algorithm finds the shortest path from the source node to all other nodes in the graph.

    5 Floyd-Warshall algorithm: This algorithm finds the shortest path between all pairs of nodes in the graph.

    6 Kruskal's algorithm: This algorithm finds a minimum spanning tree for a weighted undirected graph.

    7 Prim's algorithm: This algorithm finds a minimum spanning tree for a weighted undirected graph.

    8 Topological sort: This algorithm finds a linear ordering of the nodes in a directed acyclic graph.

    9 Johnson's algorithm: This algorithm finds the shortest path between all pairs of nodes in the graph.

    10 Tarjan's algorithm: This algorithm finds the strongly connected components in a directed graph.

    11 Kosaraju's algorithm: This algorithm finds the strongly connected components in a directed graph.

    12 Ford-Fulkerson algorithm: This algorithm finds the maximum flow in a flow network.

    13 Edmonds-Karp algorithm: This algorithm finds the maximum flow in a flow network.

    14 Hopcroft-Karp algorithm: This algorithm finds the maximum matching in a bipartite graph.
 




